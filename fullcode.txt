


################################################################################
# File: .env.example
################################################################################
BINANCE_API_KEY=your_api_key_here
BINANCE_API_SECRET=your_api_secret_here
TELEGRAM_TOKEN=your_telegram_token_here
TELEGRAM_CHAT_ID=your_telegram_chat_id_here

################################################################################
# File: .gitignore
################################################################################
.env
__pycache__/
*.pyc
bot_logs.txt
trades_history.csv

################################################################################
# File: requirements.txt
################################################################################
python-binance
requests
numpy
python-dotenv

################################################################################
# File: README.md
################################################################################
# Project Silent Core 2.0

Project Silent Core 2.0, ultra güvenli, kaldıraçsız ve agresif risk yönetimi ile hedef sermayeye ulaşmayı amaçlayan, 
çok modüllü ve entegre bir Python otomatik al-sat botudur.

## Özellikler
- Multi-timeframe analiz (15m, 1h) ile ATR, RSI, MACD, Momentum hesaplamaları.
- Yapay Zeka Destekli Haber & Sentiment Analizi (basit örnek, geliştirilebilir).
- On-Chain & Balina Takibi (placeholder değerler, ileri entegrasyon mümkün).
- Gelişmiş Reinforcement Learning (Q-learning iskeleti; DQN/PPO entegrasyonuna uygun).
- Emir Defteri ve Likidite Analizi.
- Agresif Risk Yönetimi (dinamik pozisyon büyüklüğü hesaplaması, ATR tabanlı).
- Gelişmiş Stealth Modu (rastgele gecikme, emir boyutu jitter, otomatik uyuma).
- Çok Katmanlı Strateji Optimizasyonu.
- Domino Etkisi Algılama.
- Multi-Asset Dinamik Coin Seçimi.
- Performans Altyapı Optimizasyonu (multi-threading/asenkron veri çekme).
- Paper Trading seçeneği.
- Gelişmiş Loglama & CSV kayıt.

## Kurulum
1. `.env.example` dosyasını `.env` olarak kopyalayın ve API anahtarlarınızı, Telegram bilgilerinizi girin.
2. `pip install -r requirements.txt` komutuyla paketleri yükleyin.
3. Proje dizinine girin, GitHub deposuna push edin.
4. Sunucuda veya yerel ortamda `python3 main.py` komutuyla botu başlatın.
5. Gerekirse `tests/test_backtest.py` ile backtest yapabilirsiniz.

################################################################################
# File: main.py
################################################################################
import time
import random
import traceback

from config import settings
from core.logger import BotLogger
from core.strategy import Strategy
from core.executor import ExecutorManager
from modules.time_strategy import get_current_strategy_mode
from modules.global_risk_index import GlobalRiskAnalyzer
from smart_entry.orderbook_analyzer import OrderBookAnalyzer
from security.stealth_mode import stealth
from modules.technical_analysis import (
    fetch_ohlcv_from_binance, calculate_rsi,
    calculate_macd, calculate_atr
)
# Ek modüller:
from modules.sentiment_analysis import analyze_sentiment
from modules.onchain_tracking import track_onchain_activity
from modules.dynamic_position import get_dynamic_position_size
from modules.strategy_optimizer import optimize_strategy_parameters
from modules.domino_effect import detect_domino_effect
from modules.multi_asset_selector import select_coins
from modules.performance_optimization import optimize_performance_infrastructure

logger = BotLogger()

def run_bot_cycle():
    # (0) İnsanvari gecikme
    time.sleep(random.uniform(2, 10))
    
    # (1) Stealth: Rastgele uyuma
    stealth.maybe_enter_sleep()
    
    # (2) Zaman stratejisi (özel günler dahil)
    current_mode = get_current_strategy_mode()
    
    # (3) Küresel risk analizi
    risk_analyzer = GlobalRiskAnalyzer()
    risk_level = risk_analyzer.evaluate_risk_level()
    
    # (4) Order Book analizi
    ob_analyzer = OrderBookAnalyzer()
    ob_info = ob_analyzer.analyze_liquidity_zones()
    liquidity_pressure = ob_info.get("liquidity_pressure", "neutral")
    
    # (5) Teknik analiz – Multi-timeframe (15m, 1h)
    symbol = settings.SYMBOL
    ohlcv_15m = fetch_ohlcv_from_binance(symbol, "15m", 100)
    ohlcv_1h  = fetch_ohlcv_from_binance(symbol, "1h", 100)
    
    # (5a) Haber & Sentiment Analizi
    sentiment = analyze_sentiment()
    # (5b) On-chain & Balina Takibi
    onchain_data = track_onchain_activity()
    
    # 15m verileri
    rsi_15m = macd_15m = signal_15m = None
    closes_15m = [c[4] for c in ohlcv_15m] if ohlcv_15m else []
    if len(closes_15m) >= 26:
        rsi_list_15m = calculate_rsi(closes_15m, period=14)
        if rsi_list_15m:
            rsi_15m = round(rsi_list_15m[-1], 2)
        macd_line_15m, signal_line_15m = calculate_macd(closes_15m, 12, 26, 9)
        if macd_line_15m and signal_line_15m:
            macd_15m = round(macd_line_15m[-1], 2)
            signal_15m = round(signal_line_15m[-1], 2)
    
    # 1h verileri
    rsi_1h = macd_1h = signal_1h = None
    atr_value = None
    closes_1h = [c[4] for c in ohlcv_1h] if ohlcv_1h else []
    if len(closes_1h) >= 26:
        rsi_list_1h = calculate_rsi(closes_1h, period=14)
        if rsi_list_1h:
            rsi_1h = round(rsi_list_1h[-1], 2)
        macd_line_1h, signal_line_1h = calculate_macd(closes_1h, 12, 26, 9)
        if macd_line_1h and signal_line_1h:
            macd_1h = round(macd_line_1h[-1], 2)
            signal_1h = round(signal_line_1h[-1], 2)
        if settings.USE_ATR_STOPLOSS:
            atr_value = calculate_atr(ohlcv_1h, settings.ATR_PERIOD)
            if atr_value:
                atr_value = round(atr_value, 2)
    
    # (6) Dinamik pozisyon büyüklüğü hesaplaması
    dynamic_position_size = get_dynamic_position_size(atr_value, settings.POSITION_SIZE_PCT)
    
    # (7) Strateji karar mekanizması
    strategy = Strategy()
    strategy.update_context(
        mode=current_mode,
        risk=risk_level,
        pressure=liquidity_pressure,
        rsi_15m=rsi_15m,
        macd_15m=macd_15m,
        macd_signal_15m=signal_15m,
        rsi_1h=rsi_1h,
        macd_1h=macd_1h,
        macd_signal_1h=signal_1h,
        atr=atr_value
    )
    
    # (8) Domino etkisi algılama
    domino_signal = detect_domino_effect(closes_1h)
    
    # (9) Multi-asset dinamik seçim
    selected_assets = select_coins()
    
    # (10) Performans altyapı optimizasyonu
    optimize_performance_infrastructure()
    
    # Karar ve Loglama
    decision = strategy.decide_trade()
    action = decision.get("action")
    reason = decision.get("reason", "")
    logger.log(f"[CYCLE] Mode={current_mode}, Risk={risk_level}, Press={liquidity_pressure}, "
               f"RSI15={rsi_15m}, RSI1h={rsi_1h}, MACD1h={macd_1h}/{signal_1h}, "
               f"Action={action}, Reason={reason}")
    
    # Stealth kontrolü: Eğer stealth modülü işlemi iptal ederse
    if stealth.maybe_drop_trade():
        logger.log("[STEALTH] İşlem iptal.")
        return
    
    # Emir yürütme
    executor = ExecutorManager()
    executor.manage_position(action)

def main_loop():
    logger.log("Project Silent Core (Advanced & Üretim Seviyesi) başlatılıyor...")
    retry_count = 0
    while True:
        try:
            run_bot_cycle()
            retry_count = 0
        except Exception as e:
            logger.log("[ERROR] Döngü hatası: " + str(e))
            logger.log(traceback.format_exc())
            retry_count += 1
            if retry_count < settings.MAX_RETRIES:
                wait_time = settings.RETRY_WAIT_TIME * retry_count
                logger.log(f"[ERROR] {retry_count}. retry, {wait_time}s bekleniyor...")
                time.sleep(wait_time)
            else:
                logger.log("[ERROR] Maksimum retry sayısına ulaşıldı, manuel müdahale gerekebilir.")
                retry_count = 0

        sleep_time = max(settings.CYCLE_INTERVAL + random.randint(settings.CYCLE_JITTER_MIN, settings.CYCLE_JITTER_MAX), 10)
        time.sleep(sleep_time)

if __name__ == "__main__":
    main_loop()

################################################################################
# File: config/settings.py
################################################################################
import os
from dotenv import load_dotenv

load_dotenv()

BINANCE_API_KEY = os.getenv("BINANCE_API_KEY", "")
BINANCE_API_SECRET = os.getenv("BINANCE_API_SECRET", "")

TESTNET_MODE = True
PAPER_TRADING = False
SYMBOL = "BTCUSDT"

CYCLE_INTERVAL = 60
CYCLE_JITTER_MIN = -20
CYCLE_JITTER_MAX = 20

STEALTH_DROP_CHANCE = 0.1
STEALTH_SLEEP_CHANCE = 0.05
STEALTH_SLEEP_MIN = 10
STEALTH_SLEEP_MAX = 30
STEALTH_ORDER_SIZE_JITTER = 0.05

TAKE_PROFIT_RATIO = 0.02
STOP_LOSS_RATIO = 0.005

USE_ATR_STOPLOSS = True
ATR_PERIOD = 14
ATR_MULTIPLIER = 1.2

POSITION_SIZE_PCT = 0.005

INITIAL_BALANCE = 10000.0
CSV_LOG_FILE = "trades_history.csv"
LOG_FILE = "bot_logs.txt"

MAX_RETRIES = 3
RETRY_WAIT_TIME = 10

ENABLE_PERFORMANCE_ANALYZER = True
ENABLE_AUTO_STRATEGY_OPTIMIZER = True
NOTIFIER_ENABLED = True
ANTI_BINANCE_TESPIT_ENABLED = True

TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "")

################################################################################
# File: security/stealth_mode.py
################################################################################
import random
import time
from config import settings

class StealthMode:
    def __init__(self):
        self.drop_chance = settings.STEALTH_DROP_CHANCE
        self.sleep_chance = settings.STEALTH_SLEEP_CHANCE
        self.sleep_min = settings.STEALTH_SLEEP_MIN
        self.sleep_max = settings.STEALTH_SLEEP_MAX
        self.size_jitter = settings.STEALTH_ORDER_SIZE_JITTER

    def maybe_drop_trade(self):
        if random.random() < self.drop_chance:
            print("[STEALTH] İşlem iptal edildi (drop).")
            return True
        return False

    def maybe_enter_sleep(self):
        if random.random() < self.sleep_chance:
            d = random.randint(self.sleep_min, self.sleep_max)
            print(f"[STEALTH] Botu uyutuyoruz: {d} sn")
            time.sleep(d)

    def apply_order_size_jitter(self, original_size: float):
        delta = original_size * self.size_jitter
        new_size = random.uniform(original_size - delta, original_size + delta)
        return round(new_size, 8)

    def dynamic_optimize(self, current_load):
        self.drop_chance = min(0.3, settings.STEALTH_DROP_CHANCE + current_load * 0.01)
        return self.drop_chance

stealth = StealthMode()

################################################################################
# File: modules/time_strategy.py
################################################################################
from datetime import datetime

def get_current_strategy_mode():
    now = datetime.utcnow()
    hour = now.hour
    wd = now.weekday()
    day = now.day
    if now.month == 12 and now.day == 25:
        return "auto_close"
    if 8 <= hour < 10:
        return "aggressive"
    elif 22 <= hour or hour < 2:
        return "passive"
    if wd == 0:
        return "defensive"
    elif wd == 4:
        return "volatility_focus"
    elif wd in [5, 6]:
        return "weekend_mode"
    if day <= 5:
        return "entry_focus"
    elif 25 <= day <= 31:
        return "exit_focus"
    return "neutral"

################################################################################
# File: modules/global_risk_index.py
################################################################################
import requests

class GlobalRiskAnalyzer:
    def __init__(self):
        self.url = "https://api.alternative.me/fng/"

    def fetch_fear_index(self):
        try:
            r = requests.get(self.url, timeout=5)
            data = r.json()
            return int(data["data"][0]["value"])
        except:
            return None

    def evaluate_risk_level(self):
        fear = self.fetch_fear_index()
        if fear is None:
            return "neutral"
        if fear < 25:
            return "extreme_risk"
        elif fear < 50:
            return "high_risk"
        elif fear < 75:
            return "moderate"
        else:
            return "low_risk"

    def composite_risk_score(self):
        score = self.fetch_fear_index() or 50
        return score

################################################################################
# File: smart_entry/orderbook_analyzer.py
################################################################################
import requests
from config import settings

class OrderBookAnalyzer:
    def __init__(self):
        self.symbol = settings.SYMBOL
        self.limit = 100
        self.api_url = "https://api.binance.com/api/v3/depth"

    def fetch_orderbook(self):
        try:
            params = {"symbol": self.symbol, "limit": self.limit}
            r = requests.get(self.api_url, params=params, timeout=5)
            data = r.json()
            if "bids" in data and "asks" in data:
                return data["bids"], data["asks"]
        except:
            pass
        return [], []

    def analyze_liquidity_zones(self):
        bids, asks = self.fetch_orderbook()
        if not bids or not asks:
            return {"liquidity_pressure": "neutral"}
        total_bids = sum(float(b[1]) for b in bids)
        total_asks = sum(float(a[1]) for a in asks)
        imbalance = total_bids - total_asks
        pressure = "buy_pressure" if imbalance > 0 else "sell_pressure" if imbalance < 0 else "neutral"
        volume_ratio = total_bids / total_asks if total_asks else 1
        return {"liquidity_pressure": pressure, "volume_ratio": round(volume_ratio, 2)}

################################################################################
# File: modules/technical_analysis.py
################################################################################
import requests
import numpy as np

def fetch_ohlcv_from_binance(symbol="BTCUSDT", interval="1h", limit=100):
    url = "https://api.binance.com/api/v3/klines"
    params = {"symbol": symbol, "interval": interval, "limit": limit}
    try:
        resp = requests.get(url, params=params, timeout=5)
        data = resp.json()
        ohlcv = []
        for c in data:
            ohlcv.append((
                float(c[0]),
                float(c[1]),
                float(c[2]),
                float(c[3]),
                float(c[4]),
                float(c[5])
            ))
        return ohlcv
    except Exception as e:
        print("[TA] Veri çekilemedi:", e)
        return []

def calculate_rsi(prices, period=14):
    if len(prices) < period:
        return []
    gains = []
    losses = []
    for i in range(1, len(prices)):
        diff = prices[i] - prices[i-1]
        gains.append(diff if diff > 0 else 0)
        losses.append(abs(diff) if diff < 0 else 0)
    avg_gain = sum(gains[:period]) / period
    avg_loss = sum(losses[:period]) / period
    rsi_list = [100 if avg_loss == 0 else 100 - (100 / (1 + avg_gain / avg_loss))]
    for i in range(period, len(prices) - 1):
        avg_gain = (avg_gain * (period - 1) + gains[i]) / period
        avg_loss = (avg_loss * (period - 1) + losses[i]) / period
        if avg_loss == 0:
            rsi_list.append(100)
        else:
            rs = avg_gain / avg_loss
            rsi_list.append(100 - (100 / (1 + rs)))
    return rsi_list

def calculate_ema(prices, period):
    if len(prices) < period:
        return []
    sma = sum(prices[:period]) / period
    ema_vals = [sma]
    multiplier = 2 / (period + 1)
    for i in range(period, len(prices)):
        ema_vals.append((prices[i] - ema_vals[-1]) * multiplier + ema_vals[-1])
    return ema_vals

def calculate_macd(prices, fast_period=12, slow_period=26, signal_period=9):
    if len(prices) < slow_period:
        return [], []
    fast_ema = calculate_ema(prices, fast_period)
    slow_ema = calculate_ema(prices, slow_period)
    if len(fast_ema) > len(slow_ema):
        fast_ema = fast_ema[-len(slow_ema):]
    elif len(slow_ema) > len(fast_ema):
        slow_ema = slow_ema[-len(fast_ema):]
    macd_line = np.subtract(fast_ema, slow_ema)
    signal_line = calculate_ema(macd_line, signal_period)
    if len(signal_line) < len(macd_line):
        macd_line = macd_line[-len(signal_line):]
    return macd_line, signal_line

def calculate_atr(ohlcv, period=14):
    if len(ohlcv) < period + 1:
        return None
    trs = []
    for i in range(1, len(ohlcv)):
        prev = ohlcv[i - 1]
        curr = ohlcv[i]
        high, low, prev_close = curr[2], curr[3], prev[4]
        tr = max(high - low, abs(high - prev_close), abs(low - prev_close))
        trs.append(tr)
    atr = sum(trs[:period]) / period
    atr_values = [atr]
    for i in range(period, len(trs)):
        atr_values.append((atr_values[-1] * (period - 1) + trs[i]) / period)
    return atr_values[-1] if atr_values else None

def calculate_momentum(prices, period=10):
    if len(prices) < period + 1:
        return None
    return prices[-1] - prices[-period - 1]

################################################################################
# File: modules/sentiment_analysis.py
################################################################################
def analyze_sentiment():
    # Basit örnek: sabit duyarlılık skoru (0-100, 50 nötr)
    sentiment_score = 55
    return sentiment_score

################################################################################
# File: modules/onchain_tracking.py
################################################################################
def track_onchain_activity():
    onchain_info = {
        "large_wallet_movement": False,
        "volume": 0
    }
    return onchain_info

################################################################################
# File: modules/dynamic_position.py
################################################################################
def get_dynamic_position_size(atr_value, base_position_pct):
    if atr_value is None:
        return base_position_pct
    if atr_value > 100:
        return base_position_pct * 0.5
    elif atr_value < 30:
        return base_position_pct * 1.5
    else:
        return base_position_pct

################################################################################
# File: modules/strategy_optimizer.py
################################################################################
def optimize_strategy_parameters():
    return {
        "STOP_LOSS_RATIO": 0.005,
        "TAKE_PROFIT_RATIO": 0.01
    }

################################################################################
# File: modules/domino_effect.py
################################################################################
def detect_domino_effect(prices):
    if len(prices) < 10:
        return False
    change = prices[-1] - prices[-10]
    if change < -50 or change > 50:
        return True
    return False

################################################################################
# File: modules/multi_asset_selector.py
################################################################################
def select_coins():
    return ["BTCUSDT"]

################################################################################
# File: modules/performance_optimization.py
################################################################################
def optimize_performance_infrastructure():
    print("[PERF] Performans altyapısı optimize edildi.")
    return

################################################################################
# File: core/strategy.py
################################################################################
class Strategy:
    def __init__(self):
        self.current_mode = "neutral"
        self.risk_level = "neutral"
        self.liquidity_pressure = "neutral"
        self.rsi_15m = None
        self.macd_15m = None
        self.macd_signal_15m = None
        self.rsi_1h = None
        self.macd_1h = None
        self.macd_signal_1h = None
        self.atr = None

    def update_context(self, mode, risk, pressure,
                       rsi_15m=None, macd_15m=None, macd_signal_15m=None,
                       rsi_1h=None, macd_1h=None, macd_signal_1h=None,
                       atr=None):
        self.current_mode = mode
        self.risk_level = risk
        self.liquidity_pressure = pressure
        self.rsi_15m = rsi_15m
        self.macd_15m = macd_15m
        self.macd_signal_15m = macd_signal_15m
        self.rsi_1h = rsi_1h
        self.macd_1h = macd_1h
        self.macd_signal_1h = macd_signal_1h
        self.atr = atr

    def decide_trade(self):
        score = 0
        reasons = []

        if self.risk_level == "extreme_risk":
            score -= 2
            reasons.append("ExtremeRisk")
        if self.liquidity_pressure == "buy_pressure":
            score += 1
            reasons.append("BuyPressure")
        elif self.liquidity_pressure == "sell_pressure":
            score -= 1
            reasons.append("SellPressure")

        if self.rsi_1h is not None:
            if self.rsi_1h > 70:
                score -= 1
                reasons.append("RSI1h>70")
            elif self.rsi_1h < 30:
                score += 1
                reasons.append("RSI1h<30")

        if self.macd_1h is not None and self.macd_signal_1h is not None:
            if self.macd_1h > self.macd_signal_1h:
                score += 1
                reasons.append("MACD1h>Signal")
            else:
                score -= 1
                reasons.append("MACD1h<Signal")

        if self.rsi_15m is not None:
            if self.rsi_15m < 30:
                score += 1
                reasons.append("RSI15m<30")
            elif self.rsi_15m > 70:
                score -= 1
                reasons.append("RSI15m>70")

        if self.macd_15m is not None and self.macd_signal_15m is not None:
            if self.macd_15m > self.macd_signal_15m:
                score += 1
                reasons.append("MACD15m>Signal")
            else:
                score -= 1
                reasons.append("MACD15m<Signal")

        if self.atr is not None and self.atr < 50:
            score *= 0.5
            reasons.append("LowVolatility")

        if score >= 2:
            return {"action": "BUY", "reason": "|".join(reasons)}
        elif score <= -2:
            return {"action": "SELL", "reason": "|".join(reasons)}
        else:
            return {"action": "HOLD", "reason": "|".join(reasons)}

################################################################################
# File: core/executor.py
################################################################################
import csv
import os
import time
import traceback
import math
import random

from config import settings
from core.logger import BotLogger
from security.stealth_mode import stealth

logger = BotLogger()

try:
    from binance.client import Client
    BINANCE_INSTALLED = True
except ImportError:
    BINANCE_INSTALLED = False
    logger.log("[WARN] python-binance kurulu değil, gerçek emir olmayacak.")

class ExecutorManager:
    def __init__(self):
        if settings.PAPER_TRADING:
            self.executor = PaperTradeExecutor()
        else:
            if BINANCE_INSTALLED:
                self.executor = BinanceOCOExecutor()
            else:
                self.executor = PaperTradeExecutor()

    def manage_position(self, action):
        try:
            if action == "HOLD":
                logger.log("[EXEC] HOLD => emir yok.")
                return
            self.executor.execute_trade(action)
        except Exception as e:
            logger.log(f"[EXEC] Emir hata: {e}")
            logger.log(traceback.format_exc())

class PaperTradeExecutor:
    def __init__(self):
        self.balance = settings.INITIAL_BALANCE
        self.position = 0.0
        self.avg_price = 0.0
        self.csv_file = settings.CSV_LOG_FILE
        if not os.path.exists(self.csv_file):
            with open(self.csv_file, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                writer.writerow(["timestamp", "action", "price", "amount", "balance", "position", "avg_price"])
        self.client = None
        if BINANCE_INSTALLED:
            from binance.client import Client
            self.client = Client("", "")

    def get_mock_price(self):
        symbol = settings.SYMBOL
        if self.client:
            try:
                ticker = self.client.get_symbol_ticker(symbol=symbol)
                return float(ticker["price"])
            except:
                pass
        return 28000 + 500 * math.sin(time.time() / 60)

    def execute_trade(self, action):
        mock_price = self.get_mock_price()
        usd_equity = self.balance
        trade_amount_usd = usd_equity * settings.POSITION_SIZE_PCT
        trade_amount_usd = stealth.apply_order_size_jitter(trade_amount_usd)
        amount_btc = trade_amount_usd / mock_price
        timestamp = int(time.time())

        if action == "BUY":
            cost = mock_price * amount_btc
            if cost <= self.balance:
                self.balance -= cost
                total_pos_value = self.position * self.avg_price
                new_total = total_pos_value + cost
                self.position += amount_btc
                if self.position > 0:
                    self.avg_price = new_total / self.position
                logger.log(f"[PAPER] BUY {amount_btc:.6f} BTC @ {mock_price:.2f}, Bakiye={self.balance:.2f}, Pos={self.position:.6f}")
            else:
                logger.log("[PAPER] Yetersiz bakiye, BUY başarısız.")
                return

        elif action == "SELL":
            if self.position > 0:
                if amount_btc > self.position:
                    amount_btc = self.position
                revenue = mock_price * amount_btc
                self.balance += revenue
                self.position -= amount_btc
                logger.log(f"[PAPER] SELL {amount_btc:.6f} BTC @ {mock_price:.2f}, Bakiye={self.balance:.2f}, Pos={self.position:.6f}")
                if self.position < 1e-6:
                    self.position = 0.0
                    self.avg_price = 0.0
            else:
                logger.log("[PAPER] BTC yok, SELL başarısız.")
                return

        with open(self.csv_file, "a", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow([timestamp, action, round(mock_price, 2), round(amount_btc, 6),
                             round(self.balance, 2), round(self.position, 6), round(self.avg_price, 2)])

class BinanceOCOExecutor:
    def __init__(self):
        from binance.client import Client
        self.api_key = settings.BINANCE_API_KEY
        self.api_secret = settings.BINANCE_API_SECRET
        self.symbol = settings.SYMBOL
        self.client = Client(self.api_key, self.api_secret)
        if settings.TESTNET_MODE:
            self.client.API_URL = "https://testnet.binance.vision/api"

    def execute_trade(self, action):
        account_info = self.client.get_account()
        balances = account_info["balances"]
        usdt_balance = 0.0
        btc_balance = 0.0
        for b in balances:
            if b["asset"] == "USDT":
                usdt_balance = float(b["free"])
            elif b["asset"] == "BTC":
                btc_balance = float(b["free"])

        time.sleep(random.uniform(1, 5))
        if action == "BUY":
            trade_amount_usd = usdt_balance * settings.POSITION_SIZE_PCT
            trade_amount_usd = stealth.apply_order_size_jitter(trade_amount_usd)
            ticker = self.client.get_symbol_ticker(symbol=self.symbol)
            current_price = float(ticker["price"])
            buy_qty = round(trade_amount_usd / current_price, 6)
            if buy_qty < 0.0001:
                logger.log("[BINANCE] Emir boyutu çok küçük, BUY iptal.")
                return
            logger.log(f"[BINANCE] MARKET BUY => {buy_qty} BTC @ {current_price:.2f}")
            buy_order = self.client.create_order(
                symbol=self.symbol,
                side="BUY",
                type="MARKET",
                quantity=buy_qty
            )
            logger.log(f"[BINANCE] BUY order => {buy_order}")
            time.sleep(random.uniform(2, 5))
            fills = buy_order.get("fills", [])
            fill_price = float(fills[0]["price"]) if fills else current_price
            stop_loss_price = round(fill_price * (1 - settings.STOP_LOSS_RATIO), 2)
            take_profit_price = round(fill_price * (1 + settings.TAKE_PROFIT_RATIO), 2)
            oco_qty = round(buy_qty, 6)
            if oco_qty >= 0.0001:
                try:
                    oco_order = self.client.create_oco_order(
                        symbol=self.symbol,
                        side="SELL",
                        quantity=oco_qty,
                        price=str(take_profit_price),
                        stopPrice=str(stop_loss_price),
                        stopLimitPrice=str(round(stop_loss_price * 0.999, 2)),
                        stopLimitTimeInForce="GTC"
                    )
                    logger.log(f"[BINANCE] OCO SELL => {oco_order}")
                except Exception as e:
                    logger.log(f"[BINANCE] OCO SELL hata: {e}")
        elif action == "SELL":
            if btc_balance < 0.0001:
                logger.log("[BINANCE] BTC yok, SELL iptal.")
                return
            sell_qty = round(stealth.apply_order_size_jitter(btc_balance * 0.5), 6)
            ticker = self.client.get_symbol_ticker(symbol=self.symbol)
            current_price = float(ticker["price"])
            logger.log(f"[BINANCE] MARKET SELL => {sell_qty} BTC @ {current_price:.2f}")
            sell_order = self.client.create_order(
                symbol=self.symbol,
                side="SELL",
                type="MARKET",
                quantity=sell_qty
            )
            logger.log(f"[BINANCE] SELL order => {sell_order}")

################################################################################
# File: core/logger.py
################################################################################
import datetime
from config import settings

class BotLogger:
    def __init__(self, logfile=None):
        self.logfile = logfile or settings.LOG_FILE

    def log(self, message):
        now = datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
        line = f"[{now} UTC] {message}"
        print(line)
        with open(self.logfile, "a", encoding="utf-8") as f:
            f.write(line + "\n")

################################################################################
# File: ai/reinforcement.py
################################################################################
import random
import numpy as np

class ReinforcementAgent:
    def __init__(self, actions=["BUY", "SELL", "HOLD"], alpha=0.1, gamma=0.9, epsilon=0.1):
        self.q_table = {}
        self.actions = actions
        self.alpha = alpha
        self.gamma = gamma
        self.epsilon = epsilon

    def get_state_key(self, state):
        return tuple(state.items())

    def get_action(self, state):
        key = self.get_state_key(state)
        if random.random() < self.epsilon or key not in self.q_table:
            return random.choice(self.actions)
        return max(self.q_table[key], key=self.q_table[key].get)

    def update_policy(self, state, action, reward, next_state):
        key = self.get_state_key(state)
        next_key = self.get_state_key(next_state)
        if key not in self.q_table:
            self.q_table[key] = {a: 0 for a in self.actions}
        if next_key not in self.q_table:
            self.q_table[next_key] = {a: 0 for a in self.actions}
        predict = self.q_table[key][action]
        target = reward + self.gamma * max(self.q_table[next_key].values())
        self.q_table[key][action] += self.alpha * (target - predict)
    # Gelişmiş derin öğrenme yöntemleri (DQN/PPO) entegre edilebilir.

################################################################################
# File: performance_analyzer.py
################################################################################
import csv

def analyze_performance(trade_history_file):
    trades = []
    with open(trade_history_file, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            trades.append(row)
    if not trades:
        return {}
    initial_balance = float(trades[0]["balance"])
    final_balance = float(trades[-1]["balance"])
    ROI = (final_balance - initial_balance) / initial_balance * 100
    win_trades = 0
    total_trades = 0
    balance_history = []
    for row in trades:
        total_trades += 1
        balance_history.append(float(row["balance"]))
        if row["action"] == "SELL" and float(row["price"]) > 0:
            win_trades += 1
    WinRate = (win_trades / total_trades) * 100 if total_trades else 0
    max_drawdown = 0
    peak = balance_history[0]
    for b in balance_history:
        if b > peak:
            peak = b
        drawdown = (peak - b) / peak * 100
        if drawdown > max_drawdown:
            max_drawdown = drawdown
    return {
        "ROI": round(ROI, 2),
        "WinRate": round(WinRate, 2),
        "MaxDrawdown": round(max_drawdown, 2)
    }

################################################################################
# File: auto_strategy_optimizer.py
################################################################################
import csv

def optimize_strategy(trade_history_file):
    best_params = {}
    best_roi = -float("inf")
    for sl in [0.005, 0.01, 0.015]:
        for tp in [0.01, 0.02, 0.03]:
            roi = simulate_roi(trade_history_file, sl, tp)
            if roi > best_roi:
                best_roi = roi
                best_params = {"STOP_LOSS_RATIO": sl, "TAKE_PROFIT_RATIO": tp}
    return {"optimal_params": best_params, "ROI": best_roi}

def simulate_roi(trade_history_file, sl, tp):
    total = 0
    count = 0
    with open(trade_history_file, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            price = float(row["price"])
            total += (tp - sl) * price * 0.0001
            count += 1
    return total / count if count else 0

################################################################################
# File: notifier.py
################################################################################
import requests
from config import settings

def send_notification(message):
    token = settings.TELEGRAM_TOKEN
    chat_id = settings.TELEGRAM_CHAT_ID
    if token and chat_id:
        url = f"https://api.telegram.org/bot{token}/sendMessage"
        data = {"chat_id": chat_id, "text": message}
        try:
            response = requests.post(url, data=data, timeout=5)
            return response.json()
        except Exception as e:
            print(f"Notifier Hatası: {e}")
            return None
    else:
        print("Telegram ayarları eksik.")
        return None

################################################################################
# File: anti_binance_tespit.py
################################################################################
import random
import time

def randomize_behavior():
    delay = random.uniform(0.5, 3.0)
    time.sleep(delay)
    jitter = random.uniform(-0.1, 0.1)
    return {"delay": round(delay, 2), "jitter": round(jitter, 2)}

################################################################################
# File: tests/test_backtest.py
################################################################################
from performance_analyzer import analyze_performance

def run_backtests():
    trade_history_file = "trades_history.csv"
    results = analyze_performance(trade_history_file)
    print("Backtest Sonuçları:", results)
    return results

if __name__ == "__main__":
    run_backtests()


